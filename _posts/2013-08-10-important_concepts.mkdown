---
permalink: docs/v1/important_concepts
layout: resource
---

# Important Concepts

## Some Things For Your Consideration

> Those who understand it are wise, those who do not, wander in darkness.
>
> -Isaiah Berlin

### Security

By nature, payroll information can be sensitive. As such, we take every precaution to protect the information provided to us.

#### SSL

We strictly require all API requests to be over [SSL](http://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.0). Unencrypted HTTP requests will be rejected with a 400 response status code.

<a name="versioning" markdown="1">### Versioning</a>

Versions are essentially snapshots of a given resource. If things change, we want you to find out immediately. We'd rather an extra HTTP request or 2 then employees receiving incorrect pay.

#### API Layer

The ZenPayroll API itself is versioned directly in the url - `/api/:version_string` - to allow for backwards compatibility. We guarantee that an application built with v1 of the API will always work, without changes, as long as that API version is supported. If we would like to implement breaking changes into the API, like changing request or response signatures, we will create a separate version of the API for new applications while supporting existing applications using our previous version.

#### Object Layer

Idempotency is wonderful for ensuring request safety, but in order for updates to be idempotent, they must overwrite the existing data. But what if the data in ZenPayroll has changed since you last requested it? Can you end up overwriting changes made by the other applications or the user?

For example, let's say you wish to give Frank (with id 7) a $200 bonus for the current pay period. Unbeknownst to you, another application has already given Frank a $150 bonus. You make a request to the 'Update Payroll' endpoint with a bonus of "200.00".

Your request overwrites any bonus ($150) already in our system for employee 7 for the Feb 1 - 15 pay period.

Frank is now scheduled to receive a bonus of $200, which is $150 less than the combined value of the individual bonuses. While this may be good news for Accounting, it is obviously unacceptable.

This is why versioning extends to the object level. Objects returned from the ZenPayroll API include a `version` field that denotes which version of the object you hold. This version is calculated based on all updatable attributes of this and child objects.

When updating an object, you must include this `version` field because it tells us how recently you have pulled information. If the data has changed since the last time you made a request, we will respond with the HTTP status code 409 Conflict. The client should request an updated version of the resource - which will include an updated `version` - and make a request with the updated information.

**Note**: Since versions are only updated when attributes that are updatable change (as opposed to any data returned by the API), they should not be relied on to monitor any change in the ZenPayroll database. Their design is centered around preventing race conditions and overwriting data that the request couldn't have known has changed.


<a name="authentication" markdown="1">### Authentication</a>

Authentication is done using [OAuth2](http://oauth.net/2/).

To register an application, send an email to api@zenpayroll.com with a description of your company and use case.

Upon approval, we will issue you a client id and secret, which can be used to obtain authorization codes from ZenPayroll users, and subsequently access and refresh tokens. Numerous libraries implementing the protocol can be found on the [OAuth2 homepage](http://oauth.net/2/).

Access tokens must be included in every request to the API in the `access_token` parameter.

##### Expiration Times

+ Authorization Code: 10 minutes.
+ Access Token: 2 hours.

##### URLs

+ Authorize Application with User: `GET https://zenpayroll.com/oauth/authorize`
  - `client_id` parameter should be set to your client id
  - `redirect_uri` parameter should be set to the [percent-encoded](http://en.wikipedia.org/wiki/Percent-encoding/) url you submitted when signing up for the ZenPayroll API. Should the user accept integration, the user will be returned to this url with the `code` parameter set to the authorization code.
  - `response_type` parameter should be set to `code`

+ Request an Access Token: `POST https://zenpayroll.com/oauth/token`
  - `client_id` - your client id
  - `client_secret` - your client secret
  - `redirect_uri` - the [percent-encoded](http://en.wikipedia.org/wiki/Percent-encoding/) url you submitted when signing up for the ZenPayroll API.
  - `code` - the code being exchanged for an access token. This can be a refresh token or an authorization code.
  - `grant_type` - if the `code` parameter is an authorization code, this should be "authorization_code". If the `code` parameter is a refresh token, this should be "refresh_token"

### Typical Flow

OAuth 2 is a thorough authentication protocol. Here we'll walk through a typical flow for a user authorizing your application, obtaining your first access token, and refreshing the token.

Sample Application Information:
```
  id:           bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519
  secret:       cb06cb755b868a819ead51671f0f7e9c35c7c4cbbae0e38bef167e0e4ba64ee6
  redirect_url: http://example.com/callback
```

#### Authorize Application and Receive Authorization Code

The first step is a user authorizing your application to access their information on ZenPayroll. To do this, you'll create a link to ZenPayroll where they can approve access.

The link contains the parameters outlined in the 'Authorize Application with User' URL above. For this sample application, the link would look something like this:

{% highlight html %}
  <a href="https://zenpayroll.com/oauth/authorize?client_id=bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519&redirect_uri=http%3A%2F%2Fexample.com%2Fcallback&response_type=code">Authorize with Zenpayroll</a>
{% endhighlight %}

On ZenPayroll, the user will be prompted to log in to their ZenPayroll account and authorize integration with your application for one or more of their companies.

After accepting, ZenPayroll will generate an authorization code and the user will be redirected to the redirect_uri with that code attached. In this case, the user will be sent to a url like this:

```
http://example.com/callback?code=51d5d63ae28783aecd59e7834be2c637a9ee260f241b191565aa10fe380471db
```

This parameter contains the authorization code that you will then use to obtain your first access token.

#### Exchange Authorization Code for Access Token and Refresh Token

Next, you will make a server-side request to ZenPayroll with your authorization code to `https://zenpayroll.com/oauth/token` with the parameters outlined for the 'Request an Access Token' URL above. In this case, the request would look like this:

```
https://zenpayroll.com/oauth/token?client_id=bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519&client_secret=cb06cb755b868a819ead51671f0f7e9c35c7c4cbbae0e38bef167e0e4ba64ee6&redirect_uri=http%3A%2F%2Fexample.com%2Fcallback&code=51d5d63ae28783aecd59e7834be2c637a9ee260f241b191565aa10fe380471db&grant_type=authorization_code
```

That's a lot of information there. The `client_id`, `client_secret`, and `redirect_uri` are used to identify your application. We ensure that not only is it a valid application requesting a token, but also that it is the same application to which the included `code` was granted. The `code` matches the application to the user and the `grant_type` tells us what type of code is included.

Upon successful authentication, the response will look like this:

{% highlight javascript %}
    {
     "access_token": "de6780bc506a0446309bd9362820ba8aed28aa506c71eedbe1c5c4f9dd350e54",
     "token_type": "bearer",
     "expires_in": 7200,
     "refresh_token": "8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1"
    }
{% endhighlight %}

The `access_token` should be included with every call to the API. Failure to include the `access_token` or using an expired token will result in a 401 response.

#### Refresh Access Token

Access tokens expire 2 hours after they are issued. You may exchange your refresh token for a new access token once, making a request very similar to exchanging authorization code for an access token. The only difference is that `code` is set to your refresh token and `grant_type` is set to "refresh_token". Assuming you are refreshing the access token received in the previous section, here is the request you would make:

```
https://zenpayroll.com/oauth/token?client_id=bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519&client_secret=cb06cb755b868a819ead51671f0f7e9c35c7c4cbbae0e38bef167e0e4ba64ee6&redirect_uri=http%3A%2F%2Fexample.com%2Fcallback&code=8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1&grant_type=refresh_token
```

{% highlight javascript %}
    {
     "access_token": "de6780bc506a0446309bd9362820ba8aed28aa506c71eedbe1c5c4f9dd350e54",
     "token_type": "bearer",
     "expires_in": 7200,
     "refresh_token": "8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1"
    }
{% endhighlight %}

### Idempotency

Requests are [idempotent](http://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning) such that 50 identical requests will only update the data once. This applies both to retrieving information (via GET requests) as well as updating information in the ZenPayroll ecosystem (via POST requests.)

In practice, this allows you to try identical requests multiple times without fear that data will be altered multiple times. This also means that any updates will overwrite the existing data, instead of allowing additive or incremental changes.

### Explicit vs. Contextual Intelligent Guess

Wherever possible, we prefer to have the client to specify the context precisely rather than us make assumptions that we are talking about the same thing.

For example: internally, we can identify a pay period solely by its `end_date` - we know the frequency of pay periods and can calculate `start_date`s on the fly - yet we require the `start_date` parameter when updating a payroll. This is to ensure that we both know exactly which dates data applies to. If we only required `end_date` and a company changed its pay schedule, say from monthly to bi-weekly, you could be submitting hours worked for an entire month to a 2 week pay period.

Similarly, versioning guarantees that you have up-to-date information about the state of data. This prevents race conditions and other applications unknowingly overwriting your data.